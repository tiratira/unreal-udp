// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: command.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_command_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_command_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_command_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_command_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_command_2eproto;
class CameraAxisInput;
class CameraAxisInputDefaultTypeInternal;
extern CameraAxisInputDefaultTypeInternal _CameraAxisInput_default_instance_;
class ClientFrame;
class ClientFrameDefaultTypeInternal;
extern ClientFrameDefaultTypeInternal _ClientFrame_default_instance_;
class ClientPositionSync;
class ClientPositionSyncDefaultTypeInternal;
extern ClientPositionSyncDefaultTypeInternal _ClientPositionSync_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PositionData;
class PositionDataDefaultTypeInternal;
extern PositionDataDefaultTypeInternal _PositionData_default_instance_;
class RegisterMsg;
class RegisterMsgDefaultTypeInternal;
extern RegisterMsgDefaultTypeInternal _RegisterMsg_default_instance_;
class RegisterResponse;
class RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class RouteMsg;
class RouteMsgDefaultTypeInternal;
extern RouteMsgDefaultTypeInternal _RouteMsg_default_instance_;
class ServerFrame;
class ServerFrameDefaultTypeInternal;
extern ServerFrameDefaultTypeInternal _ServerFrame_default_instance_;
class ServerFramePackage;
class ServerFramePackageDefaultTypeInternal;
extern ServerFramePackageDefaultTypeInternal _ServerFramePackage_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CameraAxisInput* Arena::CreateMaybeMessage<::CameraAxisInput>(Arena*);
template<> ::ClientFrame* Arena::CreateMaybeMessage<::ClientFrame>(Arena*);
template<> ::ClientPositionSync* Arena::CreateMaybeMessage<::ClientPositionSync>(Arena*);
template<> ::PlayerInfo* Arena::CreateMaybeMessage<::PlayerInfo>(Arena*);
template<> ::PositionData* Arena::CreateMaybeMessage<::PositionData>(Arena*);
template<> ::RegisterMsg* Arena::CreateMaybeMessage<::RegisterMsg>(Arena*);
template<> ::RegisterResponse* Arena::CreateMaybeMessage<::RegisterResponse>(Arena*);
template<> ::RouteMsg* Arena::CreateMaybeMessage<::RouteMsg>(Arena*);
template<> ::ServerFrame* Arena::CreateMaybeMessage<::ServerFrame>(Arena*);
template<> ::ServerFramePackage* Arena::CreateMaybeMessage<::ServerFramePackage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum RouteMsg_Type : int {
  RouteMsg_Type_REGISTER = 0,
  RouteMsg_Type_FRAME = 1,
  RouteMsg_Type_REGISTER_RESPONSE = 2,
  RouteMsg_Type_CLIENT_FRAME = 3,
  RouteMsg_Type_SERVER_FRAME = 4,
  RouteMsg_Type_CLIENT_POSITION_SYNC = 5,
  RouteMsg_Type_PLAYER_ENTER = 6,
  RouteMsg_Type_RouteMsg_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RouteMsg_Type_RouteMsg_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RouteMsg_Type_IsValid(int value);
constexpr RouteMsg_Type RouteMsg_Type_Type_MIN = RouteMsg_Type_REGISTER;
constexpr RouteMsg_Type RouteMsg_Type_Type_MAX = RouteMsg_Type_PLAYER_ENTER;
constexpr int RouteMsg_Type_Type_ARRAYSIZE = RouteMsg_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RouteMsg_Type_descriptor();
template<typename T>
inline const std::string& RouteMsg_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouteMsg_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouteMsg_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RouteMsg_Type_descriptor(), enum_t_value);
}
inline bool RouteMsg_Type_Parse(
    const std::string& name, RouteMsg_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RouteMsg_Type>(
    RouteMsg_Type_descriptor(), name, value);
}
// ===================================================================

class RouteMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RouteMsg) */ {
 public:
  RouteMsg();
  virtual ~RouteMsg();

  RouteMsg(const RouteMsg& from);
  RouteMsg(RouteMsg&& from) noexcept
    : RouteMsg() {
    *this = ::std::move(from);
  }

  inline RouteMsg& operator=(const RouteMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteMsg& operator=(RouteMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RouteMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteMsg* internal_default_instance() {
    return reinterpret_cast<const RouteMsg*>(
               &_RouteMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RouteMsg& a, RouteMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteMsg* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteMsg* New() const final {
    return CreateMaybeMessage<RouteMsg>(nullptr);
  }

  RouteMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RouteMsg& from);
  void MergeFrom(const RouteMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RouteMsg";
  }
  protected:
  explicit RouteMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RouteMsg_Type Type;
  static constexpr Type REGISTER =
    RouteMsg_Type_REGISTER;
  static constexpr Type FRAME =
    RouteMsg_Type_FRAME;
  static constexpr Type REGISTER_RESPONSE =
    RouteMsg_Type_REGISTER_RESPONSE;
  static constexpr Type CLIENT_FRAME =
    RouteMsg_Type_CLIENT_FRAME;
  static constexpr Type SERVER_FRAME =
    RouteMsg_Type_SERVER_FRAME;
  static constexpr Type CLIENT_POSITION_SYNC =
    RouteMsg_Type_CLIENT_POSITION_SYNC;
  static constexpr Type PLAYER_ENTER =
    RouteMsg_Type_PLAYER_ENTER;
  static inline bool Type_IsValid(int value) {
    return RouteMsg_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    RouteMsg_Type_Type_MIN;
  static constexpr Type Type_MAX =
    RouteMsg_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    RouteMsg_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return RouteMsg_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return RouteMsg_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return RouteMsg_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes msg = 2;
  void clear_msg();
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_msg();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_msg(
      std::string* msg);
  private:
  const std::string& _internal_msg() const;
  void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .RouteMsg.Type type = 1;
  void clear_type();
  ::RouteMsg_Type type() const;
  void set_type(::RouteMsg_Type value);
  private:
  ::RouteMsg_Type _internal_type() const;
  void _internal_set_type(::RouteMsg_Type value);
  public:

  // @@protoc_insertion_point(class_scope:RouteMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class RegisterMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegisterMsg) */ {
 public:
  RegisterMsg();
  virtual ~RegisterMsg();

  RegisterMsg(const RegisterMsg& from);
  RegisterMsg(RegisterMsg&& from) noexcept
    : RegisterMsg() {
    *this = ::std::move(from);
  }

  inline RegisterMsg& operator=(const RegisterMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterMsg& operator=(RegisterMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegisterMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterMsg* internal_default_instance() {
    return reinterpret_cast<const RegisterMsg*>(
               &_RegisterMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegisterMsg& a, RegisterMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterMsg* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegisterMsg* New() const final {
    return CreateMaybeMessage<RegisterMsg>(nullptr);
  }

  RegisterMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisterMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegisterMsg& from);
  void MergeFrom(const RegisterMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegisterMsg";
  }
  protected:
  explicit RegisterMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_title();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_title(
      std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:RegisterMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const final {
    return CreateMaybeMessage<RegisterResponse>(nullptr);
  }

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerListFieldNumber = 5,
    kReasonFieldNumber = 6,
    kResultFieldNumber = 1,
    kIdFieldNumber = 2,
    kPortFieldNumber = 3,
    kServerFrameFieldNumber = 4,
  };
  // repeated .PlayerInfo playerList = 5;
  int playerlist_size() const;
  private:
  int _internal_playerlist_size() const;
  public:
  void clear_playerlist();
  ::PlayerInfo* mutable_playerlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >*
      mutable_playerlist();
  private:
  const ::PlayerInfo& _internal_playerlist(int index) const;
  ::PlayerInfo* _internal_add_playerlist();
  public:
  const ::PlayerInfo& playerlist(int index) const;
  ::PlayerInfo* add_playerlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >&
      playerlist() const;

  // string reason = 6;
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_reason();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_reason(
      std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // bool result = 1;
  void clear_result();
  bool result() const;
  void set_result(bool value);
  private:
  bool _internal_result() const;
  void _internal_set_result(bool value);
  public:

  // int32 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 port = 3;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint32 serverFrame = 4;
  void clear_serverframe();
  ::PROTOBUF_NAMESPACE_ID::uint32 serverframe() const;
  void set_serverframe(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_serverframe() const;
  void _internal_set_serverframe(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:RegisterResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo > playerlist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  bool result_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 serverframe_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class ClientFrame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientFrame) */ {
 public:
  ClientFrame();
  virtual ~ClientFrame();

  ClientFrame(const ClientFrame& from);
  ClientFrame(ClientFrame&& from) noexcept
    : ClientFrame() {
    *this = ::std::move(from);
  }

  inline ClientFrame& operator=(const ClientFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientFrame& operator=(ClientFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientFrame* internal_default_instance() {
    return reinterpret_cast<const ClientFrame*>(
               &_ClientFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientFrame& a, ClientFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientFrame* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientFrame* New() const final {
    return CreateMaybeMessage<ClientFrame>(nullptr);
  }

  ClientFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientFrame& from);
  void MergeFrom(const ClientFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientFrame";
  }
  protected:
  explicit ClientFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 3,
    kClientIdFieldNumber = 1,
  };
  // .CameraAxisInput input = 3;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::CameraAxisInput& input() const;
  ::CameraAxisInput* release_input();
  ::CameraAxisInput* mutable_input();
  void set_allocated_input(::CameraAxisInput* input);
  private:
  const ::CameraAxisInput& _internal_input() const;
  ::CameraAxisInput* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::CameraAxisInput* input);
  ::CameraAxisInput* unsafe_arena_release_input();

  // int32 clientId = 1;
  void clear_clientid();
  ::PROTOBUF_NAMESPACE_ID::int32 clientid() const;
  void set_clientid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_clientid() const;
  void _internal_set_clientid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ClientFrame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CameraAxisInput* input_;
  ::PROTOBUF_NAMESPACE_ID::int32 clientid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class ServerFrame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerFrame) */ {
 public:
  ServerFrame();
  virtual ~ServerFrame();

  ServerFrame(const ServerFrame& from);
  ServerFrame(ServerFrame&& from) noexcept
    : ServerFrame() {
    *this = ::std::move(from);
  }

  inline ServerFrame& operator=(const ServerFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerFrame& operator=(ServerFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerFrame* internal_default_instance() {
    return reinterpret_cast<const ServerFrame*>(
               &_ServerFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ServerFrame& a, ServerFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerFrame* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerFrame* New() const final {
    return CreateMaybeMessage<ServerFrame>(nullptr);
  }

  ServerFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerFrame& from);
  void MergeFrom(const ServerFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerFrame";
  }
  protected:
  explicit ServerFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientInputsFieldNumber = 2,
    kFrameIdFieldNumber = 1,
  };
  // repeated .ClientFrame clientInputs = 2;
  int clientinputs_size() const;
  private:
  int _internal_clientinputs_size() const;
  public:
  void clear_clientinputs();
  ::ClientFrame* mutable_clientinputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ClientFrame >*
      mutable_clientinputs();
  private:
  const ::ClientFrame& _internal_clientinputs(int index) const;
  ::ClientFrame* _internal_add_clientinputs();
  public:
  const ::ClientFrame& clientinputs(int index) const;
  ::ClientFrame* add_clientinputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ClientFrame >&
      clientinputs() const;

  // uint32 frameId = 1;
  void clear_frameid();
  ::PROTOBUF_NAMESPACE_ID::uint32 frameid() const;
  void set_frameid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_frameid() const;
  void _internal_set_frameid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ServerFrame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ClientFrame > clientinputs_;
  ::PROTOBUF_NAMESPACE_ID::uint32 frameid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class ClientPositionSync :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientPositionSync) */ {
 public:
  ClientPositionSync();
  virtual ~ClientPositionSync();

  ClientPositionSync(const ClientPositionSync& from);
  ClientPositionSync(ClientPositionSync&& from) noexcept
    : ClientPositionSync() {
    *this = ::std::move(from);
  }

  inline ClientPositionSync& operator=(const ClientPositionSync& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientPositionSync& operator=(ClientPositionSync&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientPositionSync& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientPositionSync* internal_default_instance() {
    return reinterpret_cast<const ClientPositionSync*>(
               &_ClientPositionSync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClientPositionSync& a, ClientPositionSync& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientPositionSync* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientPositionSync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientPositionSync* New() const final {
    return CreateMaybeMessage<ClientPositionSync>(nullptr);
  }

  ClientPositionSync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientPositionSync>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientPositionSync& from);
  void MergeFrom(const ClientPositionSync& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientPositionSync* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientPositionSync";
  }
  protected:
  explicit ClientPositionSync(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kClientIdFieldNumber = 1,
  };
  // .PositionData position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::PositionData& position() const;
  ::PositionData* release_position();
  ::PositionData* mutable_position();
  void set_allocated_position(::PositionData* position);
  private:
  const ::PositionData& _internal_position() const;
  ::PositionData* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::PositionData* position);
  ::PositionData* unsafe_arena_release_position();

  // int32 clientId = 1;
  void clear_clientid();
  ::PROTOBUF_NAMESPACE_ID::int32 clientid() const;
  void set_clientid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_clientid() const;
  void _internal_set_clientid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ClientPositionSync)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PositionData* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 clientid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class ServerFramePackage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerFramePackage) */ {
 public:
  ServerFramePackage();
  virtual ~ServerFramePackage();

  ServerFramePackage(const ServerFramePackage& from);
  ServerFramePackage(ServerFramePackage&& from) noexcept
    : ServerFramePackage() {
    *this = ::std::move(from);
  }

  inline ServerFramePackage& operator=(const ServerFramePackage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerFramePackage& operator=(ServerFramePackage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerFramePackage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerFramePackage* internal_default_instance() {
    return reinterpret_cast<const ServerFramePackage*>(
               &_ServerFramePackage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ServerFramePackage& a, ServerFramePackage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerFramePackage* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerFramePackage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerFramePackage* New() const final {
    return CreateMaybeMessage<ServerFramePackage>(nullptr);
  }

  ServerFramePackage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerFramePackage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerFramePackage& from);
  void MergeFrom(const ServerFramePackage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerFramePackage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerFramePackage";
  }
  protected:
  explicit ServerFramePackage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFieldNumber = 1,
    kCache1FieldNumber = 2,
    kCache2FieldNumber = 3,
  };
  // .ServerFrame current = 1;
  bool has_current() const;
  private:
  bool _internal_has_current() const;
  public:
  void clear_current();
  const ::ServerFrame& current() const;
  ::ServerFrame* release_current();
  ::ServerFrame* mutable_current();
  void set_allocated_current(::ServerFrame* current);
  private:
  const ::ServerFrame& _internal_current() const;
  ::ServerFrame* _internal_mutable_current();
  public:
  void unsafe_arena_set_allocated_current(
      ::ServerFrame* current);
  ::ServerFrame* unsafe_arena_release_current();

  // .ServerFrame cache1 = 2;
  bool has_cache1() const;
  private:
  bool _internal_has_cache1() const;
  public:
  void clear_cache1();
  const ::ServerFrame& cache1() const;
  ::ServerFrame* release_cache1();
  ::ServerFrame* mutable_cache1();
  void set_allocated_cache1(::ServerFrame* cache1);
  private:
  const ::ServerFrame& _internal_cache1() const;
  ::ServerFrame* _internal_mutable_cache1();
  public:
  void unsafe_arena_set_allocated_cache1(
      ::ServerFrame* cache1);
  ::ServerFrame* unsafe_arena_release_cache1();

  // .ServerFrame cache2 = 3;
  bool has_cache2() const;
  private:
  bool _internal_has_cache2() const;
  public:
  void clear_cache2();
  const ::ServerFrame& cache2() const;
  ::ServerFrame* release_cache2();
  ::ServerFrame* mutable_cache2();
  void set_allocated_cache2(::ServerFrame* cache2);
  private:
  const ::ServerFrame& _internal_cache2() const;
  ::ServerFrame* _internal_mutable_cache2();
  public:
  void unsafe_arena_set_allocated_cache2(
      ::ServerFrame* cache2);
  ::ServerFrame* unsafe_arena_release_cache2();

  // @@protoc_insertion_point(class_scope:ServerFramePackage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ServerFrame* current_;
  ::ServerFrame* cache1_;
  ::ServerFrame* cache2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CameraAxisInput :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CameraAxisInput) */ {
 public:
  CameraAxisInput();
  virtual ~CameraAxisInput();

  CameraAxisInput(const CameraAxisInput& from);
  CameraAxisInput(CameraAxisInput&& from) noexcept
    : CameraAxisInput() {
    *this = ::std::move(from);
  }

  inline CameraAxisInput& operator=(const CameraAxisInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraAxisInput& operator=(CameraAxisInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraAxisInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraAxisInput* internal_default_instance() {
    return reinterpret_cast<const CameraAxisInput*>(
               &_CameraAxisInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CameraAxisInput& a, CameraAxisInput& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraAxisInput* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraAxisInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraAxisInput* New() const final {
    return CreateMaybeMessage<CameraAxisInput>(nullptr);
  }

  CameraAxisInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraAxisInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraAxisInput& from);
  void MergeFrom(const CameraAxisInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraAxisInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CameraAxisInput";
  }
  protected:
  explicit CameraAxisInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveRightFieldNumber = 1,
    kMoveForwardFieldNumber = 2,
    kCameraYawFieldNumber = 3,
    kJumpFieldNumber = 4,
  };
  // float moveRight = 1;
  void clear_moveright();
  float moveright() const;
  void set_moveright(float value);
  private:
  float _internal_moveright() const;
  void _internal_set_moveright(float value);
  public:

  // float moveForward = 2;
  void clear_moveforward();
  float moveforward() const;
  void set_moveforward(float value);
  private:
  float _internal_moveforward() const;
  void _internal_set_moveforward(float value);
  public:

  // float cameraYaw = 3;
  void clear_camerayaw();
  float camerayaw() const;
  void set_camerayaw(float value);
  private:
  float _internal_camerayaw() const;
  void _internal_set_camerayaw(float value);
  public:

  // bool jump = 4;
  void clear_jump();
  bool jump() const;
  void set_jump(bool value);
  private:
  bool _internal_jump() const;
  void _internal_set_jump(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CameraAxisInput)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float moveright_;
  float moveforward_;
  float camerayaw_;
  bool jump_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class PositionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PositionData) */ {
 public:
  PositionData();
  virtual ~PositionData();

  PositionData(const PositionData& from);
  PositionData(PositionData&& from) noexcept
    : PositionData() {
    *this = ::std::move(from);
  }

  inline PositionData& operator=(const PositionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionData& operator=(PositionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PositionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionData* internal_default_instance() {
    return reinterpret_cast<const PositionData*>(
               &_PositionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PositionData& a, PositionData& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionData* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PositionData* New() const final {
    return CreateMaybeMessage<PositionData>(nullptr);
  }

  PositionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PositionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PositionData& from);
  void MergeFrom(const PositionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PositionData";
  }
  protected:
  explicit PositionData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:PositionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return CreateMaybeMessage<PlayerInfo>(nullptr);
  }

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string title = 2;
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_title();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_title(
      std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:PlayerInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RouteMsg

// .RouteMsg.Type type = 1;
inline void RouteMsg::clear_type() {
  type_ = 0;
}
inline ::RouteMsg_Type RouteMsg::_internal_type() const {
  return static_cast< ::RouteMsg_Type >(type_);
}
inline ::RouteMsg_Type RouteMsg::type() const {
  // @@protoc_insertion_point(field_get:RouteMsg.type)
  return _internal_type();
}
inline void RouteMsg::_internal_set_type(::RouteMsg_Type value) {
  
  type_ = value;
}
inline void RouteMsg::set_type(::RouteMsg_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:RouteMsg.type)
}

// bytes msg = 2;
inline void RouteMsg::clear_msg() {
  msg_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& RouteMsg::msg() const {
  // @@protoc_insertion_point(field_get:RouteMsg.msg)
  return _internal_msg();
}
inline void RouteMsg::set_msg(const std::string& value) {
  _internal_set_msg(value);
  // @@protoc_insertion_point(field_set:RouteMsg.msg)
}
inline std::string* RouteMsg::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:RouteMsg.msg)
  return _internal_mutable_msg();
}
inline const std::string& RouteMsg::_internal_msg() const {
  return msg_.Get();
}
inline void RouteMsg::_internal_set_msg(const std::string& value) {
  
  msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void RouteMsg::set_msg(std::string&& value) {
  
  msg_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:RouteMsg.msg)
}
inline void RouteMsg::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:RouteMsg.msg)
}
inline void RouteMsg::set_msg(const void* value,
    size_t size) {
  
  msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:RouteMsg.msg)
}
inline std::string* RouteMsg::_internal_mutable_msg() {
  
  return msg_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* RouteMsg::release_msg() {
  // @@protoc_insertion_point(field_release:RouteMsg.msg)
  
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RouteMsg::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:RouteMsg.msg)
}
inline std::string* RouteMsg::unsafe_arena_release_msg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RouteMsg.msg)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return msg_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RouteMsg::unsafe_arena_set_allocated_msg(
    std::string* msg) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      msg, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RouteMsg.msg)
}

// -------------------------------------------------------------------

// RegisterMsg

// string title = 1;
inline void RegisterMsg::clear_title() {
  title_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& RegisterMsg::title() const {
  // @@protoc_insertion_point(field_get:RegisterMsg.title)
  return _internal_title();
}
inline void RegisterMsg::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:RegisterMsg.title)
}
inline std::string* RegisterMsg::mutable_title() {
  // @@protoc_insertion_point(field_mutable:RegisterMsg.title)
  return _internal_mutable_title();
}
inline const std::string& RegisterMsg::_internal_title() const {
  return title_.Get();
}
inline void RegisterMsg::_internal_set_title(const std::string& value) {
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void RegisterMsg::set_title(std::string&& value) {
  
  title_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:RegisterMsg.title)
}
inline void RegisterMsg::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:RegisterMsg.title)
}
inline void RegisterMsg::set_title(const char* value,
    size_t size) {
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:RegisterMsg.title)
}
inline std::string* RegisterMsg::_internal_mutable_title() {
  
  return title_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* RegisterMsg::release_title() {
  // @@protoc_insertion_point(field_release:RegisterMsg.title)
  
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RegisterMsg::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:RegisterMsg.title)
}
inline std::string* RegisterMsg::unsafe_arena_release_title() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RegisterMsg.title)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return title_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RegisterMsg::unsafe_arena_set_allocated_title(
    std::string* title) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (title != nullptr) {
    
  } else {
    
  }
  title_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      title, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterMsg.title)
}

// -------------------------------------------------------------------

// RegisterResponse

// bool result = 1;
inline void RegisterResponse::clear_result() {
  result_ = false;
}
inline bool RegisterResponse::_internal_result() const {
  return result_;
}
inline bool RegisterResponse::result() const {
  // @@protoc_insertion_point(field_get:RegisterResponse.result)
  return _internal_result();
}
inline void RegisterResponse::_internal_set_result(bool value) {
  
  result_ = value;
}
inline void RegisterResponse::set_result(bool value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:RegisterResponse.result)
}

// int32 id = 2;
inline void RegisterResponse::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegisterResponse::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegisterResponse::id() const {
  // @@protoc_insertion_point(field_get:RegisterResponse.id)
  return _internal_id();
}
inline void RegisterResponse::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void RegisterResponse::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:RegisterResponse.id)
}

// int32 port = 3;
inline void RegisterResponse::clear_port() {
  port_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegisterResponse::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegisterResponse::port() const {
  // @@protoc_insertion_point(field_get:RegisterResponse.port)
  return _internal_port();
}
inline void RegisterResponse::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  port_ = value;
}
inline void RegisterResponse::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:RegisterResponse.port)
}

// uint32 serverFrame = 4;
inline void RegisterResponse::clear_serverframe() {
  serverframe_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegisterResponse::_internal_serverframe() const {
  return serverframe_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegisterResponse::serverframe() const {
  // @@protoc_insertion_point(field_get:RegisterResponse.serverFrame)
  return _internal_serverframe();
}
inline void RegisterResponse::_internal_set_serverframe(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  serverframe_ = value;
}
inline void RegisterResponse::set_serverframe(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_serverframe(value);
  // @@protoc_insertion_point(field_set:RegisterResponse.serverFrame)
}

// repeated .PlayerInfo playerList = 5;
inline int RegisterResponse::_internal_playerlist_size() const {
  return playerlist_.size();
}
inline int RegisterResponse::playerlist_size() const {
  return _internal_playerlist_size();
}
inline void RegisterResponse::clear_playerlist() {
  playerlist_.Clear();
}
inline ::PlayerInfo* RegisterResponse::mutable_playerlist(int index) {
  // @@protoc_insertion_point(field_mutable:RegisterResponse.playerList)
  return playerlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >*
RegisterResponse::mutable_playerlist() {
  // @@protoc_insertion_point(field_mutable_list:RegisterResponse.playerList)
  return &playerlist_;
}
inline const ::PlayerInfo& RegisterResponse::_internal_playerlist(int index) const {
  return playerlist_.Get(index);
}
inline const ::PlayerInfo& RegisterResponse::playerlist(int index) const {
  // @@protoc_insertion_point(field_get:RegisterResponse.playerList)
  return _internal_playerlist(index);
}
inline ::PlayerInfo* RegisterResponse::_internal_add_playerlist() {
  return playerlist_.Add();
}
inline ::PlayerInfo* RegisterResponse::add_playerlist() {
  // @@protoc_insertion_point(field_add:RegisterResponse.playerList)
  return _internal_add_playerlist();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PlayerInfo >&
RegisterResponse::playerlist() const {
  // @@protoc_insertion_point(field_list:RegisterResponse.playerList)
  return playerlist_;
}

// string reason = 6;
inline void RegisterResponse::clear_reason() {
  reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& RegisterResponse::reason() const {
  // @@protoc_insertion_point(field_get:RegisterResponse.reason)
  return _internal_reason();
}
inline void RegisterResponse::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:RegisterResponse.reason)
}
inline std::string* RegisterResponse::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:RegisterResponse.reason)
  return _internal_mutable_reason();
}
inline const std::string& RegisterResponse::_internal_reason() const {
  return reason_.Get();
}
inline void RegisterResponse::_internal_set_reason(const std::string& value) {
  
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void RegisterResponse::set_reason(std::string&& value) {
  
  reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:RegisterResponse.reason)
}
inline void RegisterResponse::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:RegisterResponse.reason)
}
inline void RegisterResponse::set_reason(const char* value,
    size_t size) {
  
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:RegisterResponse.reason)
}
inline std::string* RegisterResponse::_internal_mutable_reason() {
  
  return reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* RegisterResponse::release_reason() {
  // @@protoc_insertion_point(field_release:RegisterResponse.reason)
  
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RegisterResponse::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:RegisterResponse.reason)
}
inline std::string* RegisterResponse::unsafe_arena_release_reason() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RegisterResponse.reason)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return reason_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RegisterResponse::unsafe_arena_set_allocated_reason(
    std::string* reason) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      reason, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterResponse.reason)
}

// -------------------------------------------------------------------

// ClientFrame

// int32 clientId = 1;
inline void ClientFrame::clear_clientid() {
  clientid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientFrame::_internal_clientid() const {
  return clientid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientFrame::clientid() const {
  // @@protoc_insertion_point(field_get:ClientFrame.clientId)
  return _internal_clientid();
}
inline void ClientFrame::_internal_set_clientid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  clientid_ = value;
}
inline void ClientFrame::set_clientid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:ClientFrame.clientId)
}

// .CameraAxisInput input = 3;
inline bool ClientFrame::_internal_has_input() const {
  return this != internal_default_instance() && input_ != nullptr;
}
inline bool ClientFrame::has_input() const {
  return _internal_has_input();
}
inline void ClientFrame::clear_input() {
  if (GetArenaNoVirtual() == nullptr && input_ != nullptr) {
    delete input_;
  }
  input_ = nullptr;
}
inline const ::CameraAxisInput& ClientFrame::_internal_input() const {
  const ::CameraAxisInput* p = input_;
  return p != nullptr ? *p : *reinterpret_cast<const ::CameraAxisInput*>(
      &::_CameraAxisInput_default_instance_);
}
inline const ::CameraAxisInput& ClientFrame::input() const {
  // @@protoc_insertion_point(field_get:ClientFrame.input)
  return _internal_input();
}
inline ::CameraAxisInput* ClientFrame::release_input() {
  auto temp = unsafe_arena_release_input();
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::CameraAxisInput* ClientFrame::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:ClientFrame.input)
  
  ::CameraAxisInput* temp = input_;
  input_ = nullptr;
  return temp;
}
inline ::CameraAxisInput* ClientFrame::_internal_mutable_input() {
  
  if (input_ == nullptr) {
    auto* p = CreateMaybeMessage<::CameraAxisInput>(GetArenaNoVirtual());
    input_ = p;
  }
  return input_;
}
inline ::CameraAxisInput* ClientFrame::mutable_input() {
  // @@protoc_insertion_point(field_mutable:ClientFrame.input)
  return _internal_mutable_input();
}
inline void ClientFrame::set_allocated_input(::CameraAxisInput* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:ClientFrame.input)
}

// -------------------------------------------------------------------

// ServerFrame

// uint32 frameId = 1;
inline void ServerFrame::clear_frameid() {
  frameid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerFrame::_internal_frameid() const {
  return frameid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerFrame::frameid() const {
  // @@protoc_insertion_point(field_get:ServerFrame.frameId)
  return _internal_frameid();
}
inline void ServerFrame::_internal_set_frameid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  frameid_ = value;
}
inline void ServerFrame::set_frameid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_frameid(value);
  // @@protoc_insertion_point(field_set:ServerFrame.frameId)
}

// repeated .ClientFrame clientInputs = 2;
inline int ServerFrame::_internal_clientinputs_size() const {
  return clientinputs_.size();
}
inline int ServerFrame::clientinputs_size() const {
  return _internal_clientinputs_size();
}
inline void ServerFrame::clear_clientinputs() {
  clientinputs_.Clear();
}
inline ::ClientFrame* ServerFrame::mutable_clientinputs(int index) {
  // @@protoc_insertion_point(field_mutable:ServerFrame.clientInputs)
  return clientinputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ClientFrame >*
ServerFrame::mutable_clientinputs() {
  // @@protoc_insertion_point(field_mutable_list:ServerFrame.clientInputs)
  return &clientinputs_;
}
inline const ::ClientFrame& ServerFrame::_internal_clientinputs(int index) const {
  return clientinputs_.Get(index);
}
inline const ::ClientFrame& ServerFrame::clientinputs(int index) const {
  // @@protoc_insertion_point(field_get:ServerFrame.clientInputs)
  return _internal_clientinputs(index);
}
inline ::ClientFrame* ServerFrame::_internal_add_clientinputs() {
  return clientinputs_.Add();
}
inline ::ClientFrame* ServerFrame::add_clientinputs() {
  // @@protoc_insertion_point(field_add:ServerFrame.clientInputs)
  return _internal_add_clientinputs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ClientFrame >&
ServerFrame::clientinputs() const {
  // @@protoc_insertion_point(field_list:ServerFrame.clientInputs)
  return clientinputs_;
}

// -------------------------------------------------------------------

// ClientPositionSync

// int32 clientId = 1;
inline void ClientPositionSync::clear_clientid() {
  clientid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientPositionSync::_internal_clientid() const {
  return clientid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientPositionSync::clientid() const {
  // @@protoc_insertion_point(field_get:ClientPositionSync.clientId)
  return _internal_clientid();
}
inline void ClientPositionSync::_internal_set_clientid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  clientid_ = value;
}
inline void ClientPositionSync::set_clientid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:ClientPositionSync.clientId)
}

// .PositionData position = 2;
inline bool ClientPositionSync::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool ClientPositionSync::has_position() const {
  return _internal_has_position();
}
inline void ClientPositionSync::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::PositionData& ClientPositionSync::_internal_position() const {
  const ::PositionData* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::PositionData*>(
      &::_PositionData_default_instance_);
}
inline const ::PositionData& ClientPositionSync::position() const {
  // @@protoc_insertion_point(field_get:ClientPositionSync.position)
  return _internal_position();
}
inline ::PositionData* ClientPositionSync::release_position() {
  auto temp = unsafe_arena_release_position();
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::PositionData* ClientPositionSync::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:ClientPositionSync.position)
  
  ::PositionData* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::PositionData* ClientPositionSync::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::PositionData>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::PositionData* ClientPositionSync::mutable_position() {
  // @@protoc_insertion_point(field_mutable:ClientPositionSync.position)
  return _internal_mutable_position();
}
inline void ClientPositionSync::set_allocated_position(::PositionData* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:ClientPositionSync.position)
}

// -------------------------------------------------------------------

// ServerFramePackage

// .ServerFrame current = 1;
inline bool ServerFramePackage::_internal_has_current() const {
  return this != internal_default_instance() && current_ != nullptr;
}
inline bool ServerFramePackage::has_current() const {
  return _internal_has_current();
}
inline void ServerFramePackage::clear_current() {
  if (GetArenaNoVirtual() == nullptr && current_ != nullptr) {
    delete current_;
  }
  current_ = nullptr;
}
inline const ::ServerFrame& ServerFramePackage::_internal_current() const {
  const ::ServerFrame* p = current_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ServerFrame*>(
      &::_ServerFrame_default_instance_);
}
inline const ::ServerFrame& ServerFramePackage::current() const {
  // @@protoc_insertion_point(field_get:ServerFramePackage.current)
  return _internal_current();
}
inline ::ServerFrame* ServerFramePackage::release_current() {
  auto temp = unsafe_arena_release_current();
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ServerFrame* ServerFramePackage::unsafe_arena_release_current() {
  // @@protoc_insertion_point(field_release:ServerFramePackage.current)
  
  ::ServerFrame* temp = current_;
  current_ = nullptr;
  return temp;
}
inline ::ServerFrame* ServerFramePackage::_internal_mutable_current() {
  
  if (current_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerFrame>(GetArenaNoVirtual());
    current_ = p;
  }
  return current_;
}
inline ::ServerFrame* ServerFramePackage::mutable_current() {
  // @@protoc_insertion_point(field_mutable:ServerFramePackage.current)
  return _internal_mutable_current();
}
inline void ServerFramePackage::set_allocated_current(::ServerFrame* current) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete current_;
  }
  if (current) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(current);
    if (message_arena != submessage_arena) {
      current = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current, submessage_arena);
    }
    
  } else {
    
  }
  current_ = current;
  // @@protoc_insertion_point(field_set_allocated:ServerFramePackage.current)
}

// .ServerFrame cache1 = 2;
inline bool ServerFramePackage::_internal_has_cache1() const {
  return this != internal_default_instance() && cache1_ != nullptr;
}
inline bool ServerFramePackage::has_cache1() const {
  return _internal_has_cache1();
}
inline void ServerFramePackage::clear_cache1() {
  if (GetArenaNoVirtual() == nullptr && cache1_ != nullptr) {
    delete cache1_;
  }
  cache1_ = nullptr;
}
inline const ::ServerFrame& ServerFramePackage::_internal_cache1() const {
  const ::ServerFrame* p = cache1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ServerFrame*>(
      &::_ServerFrame_default_instance_);
}
inline const ::ServerFrame& ServerFramePackage::cache1() const {
  // @@protoc_insertion_point(field_get:ServerFramePackage.cache1)
  return _internal_cache1();
}
inline ::ServerFrame* ServerFramePackage::release_cache1() {
  auto temp = unsafe_arena_release_cache1();
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ServerFrame* ServerFramePackage::unsafe_arena_release_cache1() {
  // @@protoc_insertion_point(field_release:ServerFramePackage.cache1)
  
  ::ServerFrame* temp = cache1_;
  cache1_ = nullptr;
  return temp;
}
inline ::ServerFrame* ServerFramePackage::_internal_mutable_cache1() {
  
  if (cache1_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerFrame>(GetArenaNoVirtual());
    cache1_ = p;
  }
  return cache1_;
}
inline ::ServerFrame* ServerFramePackage::mutable_cache1() {
  // @@protoc_insertion_point(field_mutable:ServerFramePackage.cache1)
  return _internal_mutable_cache1();
}
inline void ServerFramePackage::set_allocated_cache1(::ServerFrame* cache1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cache1_;
  }
  if (cache1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cache1);
    if (message_arena != submessage_arena) {
      cache1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cache1, submessage_arena);
    }
    
  } else {
    
  }
  cache1_ = cache1;
  // @@protoc_insertion_point(field_set_allocated:ServerFramePackage.cache1)
}

// .ServerFrame cache2 = 3;
inline bool ServerFramePackage::_internal_has_cache2() const {
  return this != internal_default_instance() && cache2_ != nullptr;
}
inline bool ServerFramePackage::has_cache2() const {
  return _internal_has_cache2();
}
inline void ServerFramePackage::clear_cache2() {
  if (GetArenaNoVirtual() == nullptr && cache2_ != nullptr) {
    delete cache2_;
  }
  cache2_ = nullptr;
}
inline const ::ServerFrame& ServerFramePackage::_internal_cache2() const {
  const ::ServerFrame* p = cache2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ServerFrame*>(
      &::_ServerFrame_default_instance_);
}
inline const ::ServerFrame& ServerFramePackage::cache2() const {
  // @@protoc_insertion_point(field_get:ServerFramePackage.cache2)
  return _internal_cache2();
}
inline ::ServerFrame* ServerFramePackage::release_cache2() {
  auto temp = unsafe_arena_release_cache2();
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ServerFrame* ServerFramePackage::unsafe_arena_release_cache2() {
  // @@protoc_insertion_point(field_release:ServerFramePackage.cache2)
  
  ::ServerFrame* temp = cache2_;
  cache2_ = nullptr;
  return temp;
}
inline ::ServerFrame* ServerFramePackage::_internal_mutable_cache2() {
  
  if (cache2_ == nullptr) {
    auto* p = CreateMaybeMessage<::ServerFrame>(GetArenaNoVirtual());
    cache2_ = p;
  }
  return cache2_;
}
inline ::ServerFrame* ServerFramePackage::mutable_cache2() {
  // @@protoc_insertion_point(field_mutable:ServerFramePackage.cache2)
  return _internal_mutable_cache2();
}
inline void ServerFramePackage::set_allocated_cache2(::ServerFrame* cache2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cache2_;
  }
  if (cache2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cache2);
    if (message_arena != submessage_arena) {
      cache2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cache2, submessage_arena);
    }
    
  } else {
    
  }
  cache2_ = cache2;
  // @@protoc_insertion_point(field_set_allocated:ServerFramePackage.cache2)
}

// -------------------------------------------------------------------

// CameraAxisInput

// float moveRight = 1;
inline void CameraAxisInput::clear_moveright() {
  moveright_ = 0;
}
inline float CameraAxisInput::_internal_moveright() const {
  return moveright_;
}
inline float CameraAxisInput::moveright() const {
  // @@protoc_insertion_point(field_get:CameraAxisInput.moveRight)
  return _internal_moveright();
}
inline void CameraAxisInput::_internal_set_moveright(float value) {
  
  moveright_ = value;
}
inline void CameraAxisInput::set_moveright(float value) {
  _internal_set_moveright(value);
  // @@protoc_insertion_point(field_set:CameraAxisInput.moveRight)
}

// float moveForward = 2;
inline void CameraAxisInput::clear_moveforward() {
  moveforward_ = 0;
}
inline float CameraAxisInput::_internal_moveforward() const {
  return moveforward_;
}
inline float CameraAxisInput::moveforward() const {
  // @@protoc_insertion_point(field_get:CameraAxisInput.moveForward)
  return _internal_moveforward();
}
inline void CameraAxisInput::_internal_set_moveforward(float value) {
  
  moveforward_ = value;
}
inline void CameraAxisInput::set_moveforward(float value) {
  _internal_set_moveforward(value);
  // @@protoc_insertion_point(field_set:CameraAxisInput.moveForward)
}

// float cameraYaw = 3;
inline void CameraAxisInput::clear_camerayaw() {
  camerayaw_ = 0;
}
inline float CameraAxisInput::_internal_camerayaw() const {
  return camerayaw_;
}
inline float CameraAxisInput::camerayaw() const {
  // @@protoc_insertion_point(field_get:CameraAxisInput.cameraYaw)
  return _internal_camerayaw();
}
inline void CameraAxisInput::_internal_set_camerayaw(float value) {
  
  camerayaw_ = value;
}
inline void CameraAxisInput::set_camerayaw(float value) {
  _internal_set_camerayaw(value);
  // @@protoc_insertion_point(field_set:CameraAxisInput.cameraYaw)
}

// bool jump = 4;
inline void CameraAxisInput::clear_jump() {
  jump_ = false;
}
inline bool CameraAxisInput::_internal_jump() const {
  return jump_;
}
inline bool CameraAxisInput::jump() const {
  // @@protoc_insertion_point(field_get:CameraAxisInput.jump)
  return _internal_jump();
}
inline void CameraAxisInput::_internal_set_jump(bool value) {
  
  jump_ = value;
}
inline void CameraAxisInput::set_jump(bool value) {
  _internal_set_jump(value);
  // @@protoc_insertion_point(field_set:CameraAxisInput.jump)
}

// -------------------------------------------------------------------

// PositionData

// float x = 1;
inline void PositionData::clear_x() {
  x_ = 0;
}
inline float PositionData::_internal_x() const {
  return x_;
}
inline float PositionData::x() const {
  // @@protoc_insertion_point(field_get:PositionData.x)
  return _internal_x();
}
inline void PositionData::_internal_set_x(float value) {
  
  x_ = value;
}
inline void PositionData::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:PositionData.x)
}

// float y = 2;
inline void PositionData::clear_y() {
  y_ = 0;
}
inline float PositionData::_internal_y() const {
  return y_;
}
inline float PositionData::y() const {
  // @@protoc_insertion_point(field_get:PositionData.y)
  return _internal_y();
}
inline void PositionData::_internal_set_y(float value) {
  
  y_ = value;
}
inline void PositionData::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:PositionData.y)
}

// float z = 3;
inline void PositionData::clear_z() {
  z_ = 0;
}
inline float PositionData::_internal_z() const {
  return z_;
}
inline float PositionData::z() const {
  // @@protoc_insertion_point(field_get:PositionData.z)
  return _internal_z();
}
inline void PositionData::_internal_set_z(float value) {
  
  z_ = value;
}
inline void PositionData::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:PositionData.z)
}

// -------------------------------------------------------------------

// PlayerInfo

// int32 id = 1;
inline void PlayerInfo::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::id() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.id)
  return _internal_id();
}
inline void PlayerInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void PlayerInfo::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.id)
}

// string title = 2;
inline void PlayerInfo::clear_title() {
  title_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& PlayerInfo::title() const {
  // @@protoc_insertion_point(field_get:PlayerInfo.title)
  return _internal_title();
}
inline void PlayerInfo::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:PlayerInfo.title)
}
inline std::string* PlayerInfo::mutable_title() {
  // @@protoc_insertion_point(field_mutable:PlayerInfo.title)
  return _internal_mutable_title();
}
inline const std::string& PlayerInfo::_internal_title() const {
  return title_.Get();
}
inline void PlayerInfo::_internal_set_title(const std::string& value) {
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
}
inline void PlayerInfo::set_title(std::string&& value) {
  
  title_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:PlayerInfo.title)
}
inline void PlayerInfo::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:PlayerInfo.title)
}
inline void PlayerInfo::set_title(const char* value,
    size_t size) {
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:PlayerInfo.title)
}
inline std::string* PlayerInfo::_internal_mutable_title() {
  
  return title_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* PlayerInfo::release_title() {
  // @@protoc_insertion_point(field_release:PlayerInfo.title)
  
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void PlayerInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:PlayerInfo.title)
}
inline std::string* PlayerInfo::unsafe_arena_release_title() {
  // @@protoc_insertion_point(field_unsafe_arena_release:PlayerInfo.title)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return title_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void PlayerInfo::unsafe_arena_set_allocated_title(
    std::string* title) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (title != nullptr) {
    
  } else {
    
  }
  title_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      title, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PlayerInfo.title)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::RouteMsg_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RouteMsg_Type>() {
  return ::RouteMsg_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_command_2eproto
